<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar System Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        .ui-panel {
            position: fixed;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            color: white;
            z-index: 100;
        }

        .planet-list {
            top: 20px;
            left: 20px;
            max-width: 280px;
            max-height: calc(100vh - 140px);  /* Leave room for time controls */
            overflow-y: auto;
            transition: all 0.3s ease;
            z-index: 1000;  /* Above time controls */
        }

        .planet-list.minimized {
            max-width: 60px;
            padding: 12px;
        }

        .planet-list.minimized .planet-items,
        .planet-list.minimized .planet-list-title {
            display: none;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .planet-list h2 {
            font-size: 18px;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .minimize-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s;
        }

        .minimize-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .planet-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .planet-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(4px);
        }

        .planet-item.selected {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            border-color: rgba(102, 126, 234, 0.5);
        }

        .planet-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
        }

        .planet-name {
            font-size: 14px;
            font-weight: 500;
        }

        .controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: flex-end;
            transition: all 0.3s ease;
            flex-wrap: wrap;
            max-width: 90vw;
        }

        .control-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-controls {
            flex-direction: column;
            align-items: stretch;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-width: 200px;
        }

        .controls.minimized {
            gap: 0;
        }

        .controls.minimized .control-section {
            display: none;
        }

        .controls.minimized button:not(.minimize-btn) {
            display: none;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        button.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
            border-color: rgba(102, 126, 234, 0.5);
        }

        .info-panel {
            top: 20px;
            right: 20px;
            max-width: 300px;
            z-index: 1002;  /* Above hamburger menu */
        }

        .info-panel h3 {
            font-size: 20px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .info-panel p {
            font-size: 13px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 12px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-value {
            font-weight: 600;
        }

        .hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: #ffd60a;
        }

        @media (max-width: 768px) {
            .planet-list {
                bottom: 80px;
                top: auto;
                left: 10px;
                right: 10px;
                max-width: none;
            }

            .planet-list.minimized {
                max-width: 60px;
                left: 10px;
                right: auto;
            }

            .info-panel {
                top: 20px;
                left: 10px;
                right: 10px;
                max-width: none;
            }

            .info-panel.minimized {
                max-width: 60px;
                right: auto;
            }

            .info-panel.minimized > *:not(.panel-header) {
                display: none;
            }

            .controls {
                bottom: 10px;
            }

            .controls.minimized {
                left: auto;
                right: 10px;
                transform: none;
            }

            .hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="loading" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; z-index: 1000;">
        <div style="font-size: 48px; margin-bottom: 20px;">üåç</div>
        <div style="font-size: 18px;">Loading Solar System...</div>
        <div style="font-size: 14px; color: #888; margin-top: 10px;">If this persists, try refreshing</div>
    </div>
    <div id="container"></div>

    <!-- Hamburger menu button -->
    <button id="hamburgerBtn" style="position: fixed; top: 20px; left: 20px; z-index: 1001; width: 48px; height: 48px; background: rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; transition: all 0.3s;">
        <span style="width: 24px; height: 2px; background: white; transition: all 0.3s;"></span>
        <span style="width: 24px; height: 2px; background: white; transition: all 0.3s;"></span>
        <span style="width: 24px; height: 2px; background: white; transition: all 0.3s;"></span>
    </button>

    <div class="ui-panel planet-list" id="planetListPanel" style="transform: translateX(calc(-100% - 20px)); transition: transform 0.3s;">
        <div class="panel-header" style="justify-content: center; position: relative;">
            <h2 class="planet-list-title" style="text-align: center;">ü™ê Solar System</h2>
            <button class="minimize-btn" id="closePlanets" style="border-radius: 8px; width: 36px; position: absolute; right: 0;">‚úï</button>
        </div>
        <div class="planet-items" id="planetList"></div>
    </div>

    <!-- Time slider at bottom -->
    <div id="timeSliderContainer" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 600px; background: rgba(0,0,0,0.85); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 20px; z-index: 50; backdrop-filter: blur(10px);">
        <div style="text-align: center; margin-bottom: 10px; position: relative;">
            <div id="currentDateDisplay" style="font-size: 16px; color: white; font-weight: bold; margin-bottom: 8px; padding: 8px; border-radius: 6px; pointer-events: none;">Jan 18, 2026 üìÖ</div>
            <input type="datetime-local" id="hiddenDatePicker" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 200px; height: 40px; opacity: 0; cursor: pointer; z-index: 10;">
            <div id="timeSpeedDisplay" style="font-size: 14px; color: #888;">Paused</div>
        </div>
        <div style="position: relative; height: 40px; display: flex; align-items: center;">
            <div id="timeSliderTrack" style="position: relative; width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; cursor: pointer;">
                <div id="timeSliderHandle" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 32px; height: 32px; background: #667eea; border: 3px solid white; border-radius: 50%; cursor: grab; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: transform 0.1s;"></div>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 12px; margin-top: 12px;">
            <button id="pauseBtn2">‚è∏Ô∏è Pause</button>
            <button id="resetDateBtn2">Now</button>
        </div>
    </div>

    <div class="ui-panel info-panel" id="infoPanel" style="display: none;">
        <div class="panel-header">
            <h3 id="planetTitle">Earth</h3>
            <button class="minimize-btn" id="minimizeInfo">‚àí</button>
        </div>
        <p id="planetDesc"></p>
        <div id="planetStats"></div>
    </div>

    <div class="hint">Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click planets to focus</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <script>
        // Global error handler
        window.addEventListener('error', (e) => {
            console.error('Error:', e.message);
            const loading = document.getElementById('loading');
            if (loading) {
                loading.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                    <div style="font-size: 18px;">Something went wrong</div>
                    <div style="font-size: 14px; color: #888; margin-top: 10px;">
                        ${e.message || 'Please refresh the page'}
                    </div>
                `;
            }
        });
    </script>

    <script>
        // Check if Three.js loaded
        if (typeof THREE === 'undefined') {
            document.getElementById('loading').innerHTML = `
                <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                <div style="font-size: 18px;">Failed to load 3D engine</div>
                <div style="font-size: 14px; color: #888; margin-top: 10px;">
                    Please check your internet connection and refresh
                </div>
            `;
            throw new Error('Three.js failed to load');
        }

        // Planet data with real NASA orbital parameters
        // Distances scaled for visualization (actual ratios preserved)
        // Orbital elements from NASA JPL Horizons
        // Epoch: J2000.0 (January 1, 2000, 12:00 TT)
        const PLANETS = {
            mercury: {
                name: 'Mercury',
                radius: 0.383,  // Actual radius relative to Earth
                semiMajorAxis: 5.8,      // 0.387 AU scaled
                eccentricity: 0.2056,     // Real eccentricity
                inclination: 7.005,       // degrees
                longitudeAscending: 48.331, // Œ© degrees
                argumentPeriapsis: 29.124,  // œâ degrees
                meanAnomalyEpoch: 174.796,  // M0 at J2000.0 (degrees)
                orbit: 87.969,            // Orbital period in days
                rotation: 58.6,
                color: '#8C7853',
                desc: 'The smallest planet and closest to the Sun.'
            },
            venus: {
                name: 'Venus',
                radius: 0.949,  // Actual radius relative to Earth
                semiMajorAxis: 10.8,
                eccentricity: 0.0068,
                inclination: 3.395,
                longitudeAscending: 76.680,
                argumentPeriapsis: 54.884,
                meanAnomalyEpoch: 50.115,
                orbit: 224.701,
                rotation: 243,
                color: '#FFC649',
                desc: 'Earth\'s "sister planet" with a thick toxic atmosphere.'
            },
            earth: {
                name: 'Earth',
                radius: 1.000,  // Reference: Earth radius
                semiMajorAxis: 15.0,      // 1.000 AU - reference
                eccentricity: 0.0167,
                inclination: 0.000,       // Reference plane
                longitudeAscending: 0.0,
                argumentPeriapsis: 114.208,
                meanAnomalyEpoch: 357.529,
                orbit: 365.256,           // Sidereal year
                rotation: 1,
                color: '#4169E1',
                desc: 'Our home planet with liquid water and life.'
            },
            mars: {
                name: 'Mars',
                radius: 0.532,  // Actual radius relative to Earth
                semiMajorAxis: 22.9,
                eccentricity: 0.0934,
                inclination: 1.850,
                longitudeAscending: 49.558,
                argumentPeriapsis: 286.502,
                meanAnomalyEpoch: 19.373,
                orbit: 686.980,
                rotation: 1.03,
                color: '#CD5C5C',
                desc: 'The Red Planet with the largest volcano in the solar system.'
            },
            jupiter: {
                name: 'Jupiter',
                radius: 11.21,  // Actual radius relative to Earth
                semiMajorAxis: 78.0,
                eccentricity: 0.0489,
                inclination: 1.303,
                longitudeAscending: 100.464,
                argumentPeriapsis: 273.867,
                meanAnomalyEpoch: 20.020,
                orbit: 4332.589,
                rotation: 0.41,
                color: '#DAA520',
                desc: 'The largest planet, a gas giant with the Great Red Spot.'
            },
            saturn: {
                name: 'Saturn',
                radius: 9.45,  // Actual radius relative to Earth
                semiMajorAxis: 143.1,
                eccentricity: 0.0565,
                inclination: 2.485,
                longitudeAscending: 113.665,
                argumentPeriapsis: 339.392,
                meanAnomalyEpoch: 317.021,
                orbit: 10759.22,
                rotation: 0.45,
                color: '#F4E3B5',
                desc: 'The ringed planet with spectacular ice and rock rings.'
            },
            uranus: {
                name: 'Uranus',
                radius: 4.01,  // Actual radius relative to Earth
                semiMajorAxis: 287.9,
                eccentricity: 0.0457,
                inclination: 0.773,
                longitudeAscending: 74.006,
                argumentPeriapsis: 96.998,
                meanAnomalyEpoch: 141.050,
                orbit: 30688.5,
                rotation: 0.72,
                color: '#4FD0E7',
                desc: 'The ice giant that rotates on its side.'
            },
            neptune: {
                name: 'Neptune',
                radius: 3.88,  // Actual radius relative to Earth
                semiMajorAxis: 451.0,
                eccentricity: 0.0113,
                inclination: 1.770,
                longitudeAscending: 131.784,
                argumentPeriapsis: 276.336,
                meanAnomalyEpoch: 256.225,
                orbit: 60182.0,
                rotation: 0.67,
                color: '#4169E1',
                desc: 'The farthest planet with the fastest winds.'
            }
        };

        // Moon data with real NASA orbital parameters
        // Orbital elements relative to their parent planets
        const MOONS = {
            moon: {
                name: 'Moon',
                parent: 'earth',
                radius: 0.27,  // Relative to Earth
                semiMajorAxis: 0.0384,  // 384,400 km = 0.00257 AU scaled to 15 units/AU
                eccentricity: 0.0549,
                inclination: 5.145,  // degrees relative to ecliptic
                longitudeAscending: 125.08,
                argumentPeriapsis: 318.15,
                meanAnomalyEpoch: 135.27,
                orbit: 27.322,  // days
                color: '#AAAAAA'
            },
            phobos: {
                name: 'Phobos',
                parent: 'mars',
                radius: 0.02,
                semiMajorAxis: 0.0094,  // 9,376 km
                eccentricity: 0.0151,
                inclination: 1.093,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 0,
                orbit: 0.319,  // 7.65 hours
                color: '#8B7355'
            },
            deimos: {
                name: 'Deimos',
                parent: 'mars',
                radius: 0.015,
                semiMajorAxis: 0.0235,  // 23,463 km
                eccentricity: 0.0002,
                inclination: 0.93,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 180,
                orbit: 1.262,  // days
                color: '#9B8366'
            },
            io: {
                name: 'Io',
                parent: 'jupiter',
                radius: 0.29,
                semiMajorAxis: 0.0422,  // 421,700 km
                eccentricity: 0.0041,
                inclination: 0.05,
                longitudeAscending: 43.977,
                argumentPeriapsis: 84.129,
                meanAnomalyEpoch: 342.21,
                orbit: 1.769,  // days
                color: '#FFD700'
            },
            europa: {
                name: 'Europa',
                parent: 'jupiter',
                radius: 0.245,
                semiMajorAxis: 0.0671,  // 671,000 km
                eccentricity: 0.0094,
                inclination: 0.47,
                longitudeAscending: 219.106,
                argumentPeriapsis: 88.970,
                meanAnomalyEpoch: 171.016,
                orbit: 3.551,  // days
                color: '#C9C9D4'
            },
            ganymede: {
                name: 'Ganymede',
                parent: 'jupiter',
                radius: 0.413,
                semiMajorAxis: 0.107,  // 1,070,000 km
                eccentricity: 0.0013,
                inclination: 0.20,
                longitudeAscending: 63.552,
                argumentPeriapsis: 192.417,
                meanAnomalyEpoch: 317.540,
                orbit: 7.155,  // days
                color: '#8B8B9F'
            },
            callisto: {
                name: 'Callisto',
                parent: 'jupiter',
                radius: 0.378,
                semiMajorAxis: 0.188,  // 1,880,000 km
                eccentricity: 0.0074,
                inclination: 0.19,
                longitudeAscending: 298.848,
                argumentPeriapsis: 52.643,
                meanAnomalyEpoch: 181.408,
                orbit: 16.689,  // days
                color: '#696969'
            },
            titan: {
                name: 'Titan',
                parent: 'saturn',
                radius: 0.404,
                semiMajorAxis: 0.122,  // 1,220,000 km
                eccentricity: 0.0288,
                inclination: 0.28,
                longitudeAscending: 28.06,
                argumentPeriapsis: 180.532,
                meanAnomalyEpoch: 163.51,
                orbit: 15.945,  // days
                color: '#FFA500'
            },
            rhea: {
                name: 'Rhea',
                parent: 'saturn',
                radius: 0.12,
                semiMajorAxis: 0.0527,  // 527,000 km
                eccentricity: 0.0010,
                inclination: 0.35,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 90,
                orbit: 4.518,  // days
                color: '#E0E0E0'
            },
            enceladus: {
                name: 'Enceladus',
                parent: 'saturn',
                radius: 0.04,
                semiMajorAxis: 0.0238,  // 238,000 km
                eccentricity: 0.0047,
                inclination: 0.009,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 270,
                orbit: 1.370,  // days
                color: '#F0F8FF'
            },
            titania: {
                name: 'Titania',
                parent: 'uranus',
                radius: 0.124,
                semiMajorAxis: 0.0436,  // 436,000 km
                eccentricity: 0.0011,
                inclination: 0.34,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 0,
                orbit: 8.706,  // days
                color: '#B0C4DE'
            },
            oberon: {
                name: 'Oberon',
                parent: 'uranus',
                radius: 0.119,
                semiMajorAxis: 0.0584,  // 584,000 km
                eccentricity: 0.0014,
                inclination: 0.07,
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 180,
                orbit: 13.463,  // days
                color: '#9FB6CD'
            },
            triton: {
                name: 'Triton',
                parent: 'neptune',
                radius: 0.212,
                semiMajorAxis: 0.0355,  // 355,000 km
                eccentricity: 0.000016,
                inclination: 156.885,  // Retrograde orbit!
                longitudeAscending: 0,
                argumentPeriapsis: 0,
                meanAnomalyEpoch: 0,
                orbit: -5.877,  // Negative = retrograde
                color: '#FFB6C1'
            }
        };

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        scene.background = new THREE.Color(0x000510);
        camera.position.set(0, 50, 80);  // Higher camera to see orbital inclinations

        // Lights
        const sunLight = new THREE.PointLight(0xffffff, 3, 0);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        // Stars (infinitely distant - no parallax)
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            sizeAttenuation: false  // Stars don't get smaller with distance
        });
        const starsVertices = [];
        // Create stars on a large sphere that will follow the camera
        for (let i = 0; i < 2000; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = 10000;  // Very far away
            starsVertices.push(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Sun
        const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xFDB813,
            emissive: 0xFDB813,
            emissiveIntensity: 1
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Sun glow
        const glowGeometry = new THREE.SphereGeometry(3.2, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFDB813,
            transparent: true,
            opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);

        // Date/Time functionality for accurate planet positions
        // J2000.0 epoch: January 1, 2000, 12:00 TT (approximately 11:58:55.816 UTC)
        const J2000 = new Date('2000-01-01T12:00:00Z');
        const J2000_JD = 2451545.0;  // Julian Date of J2000.0

        // Convert JavaScript Date to Julian Date
        function dateToJulianDate(date) {
            return (date.getTime() / 86400000) + 2440587.5;
        }

        // Calculate mean anomaly at a given date
        function getMeanAnomalyAtDate(planet, date) {
            const jd = dateToJulianDate(date);
            const daysSinceEpoch = jd - J2000_JD;

            // Mean motion (degrees per day)
            const meanMotion = 360.0 / planet.orbit;

            // Mean anomaly = M0 + n * t (where n is mean motion, t is time since epoch)
            const meanAnomaly = planet.meanAnomalyEpoch + (meanMotion * daysSinceEpoch);

            // Normalize to 0-360 degrees
            return ((meanAnomaly % 360) + 360) % 360;
        }

        // Helper function to calculate position on elliptical orbit
        function getOrbitalPosition(planet, meanAnomaly) {
            const a = planet.semiMajorAxis;
            const e = planet.eccentricity;
            const inc = planet.inclination * Math.PI / 180;
            const omega = planet.longitudeAscending * Math.PI / 180;
            const w = planet.argumentPeriapsis * Math.PI / 180;

            // Solve Kepler's equation to get eccentric anomaly (simplified Newton-Raphson)
            let E = meanAnomaly;
            for (let iter = 0; iter < 5; iter++) {
                E = meanAnomaly + e * Math.sin(E);
            }

            // Calculate true anomaly from eccentric anomaly
            const nu = 2 * Math.atan2(
                Math.sqrt(1 + e) * Math.sin(E / 2),
                Math.sqrt(1 - e) * Math.cos(E / 2)
            );

            // Orbital radius
            const r = a * (1 - e * e) / (1 + e * Math.cos(nu));

            // Position in orbital plane
            const x_orb = r * Math.cos(nu);
            const y_orb = r * Math.sin(nu);

            // Rotate by argument of periapsis
            const x_peri = x_orb * Math.cos(w) - y_orb * Math.sin(w);
            const y_peri = x_orb * Math.sin(w) + y_orb * Math.cos(w);

            // Apply 3D rotations for inclination and ascending node
            const x_inc = x_peri;
            const y_inc = y_peri * Math.cos(inc);
            const z_inc = y_peri * Math.sin(inc);

            const x = x_inc * Math.cos(omega) - y_inc * Math.sin(omega);
            const y = x_inc * Math.sin(omega) + y_inc * Math.cos(omega);
            const z = z_inc;

            return { x, y: z, z: y };  // THREE.js uses Y-up
        }

        // Helper function to create elliptical orbit with proper 3D orientation
        function createEllipticalOrbit(planet) {
            const points = [];
            const segments = 128;

            for (let i = 0; i <= segments; i++) {
                const meanAnomaly = (i / segments) * Math.PI * 2;
                const pos = getOrbitalPosition(planet, meanAnomaly);
                points.push(pos.x, pos.y, pos.z);
            }

            return points;
        }

        // Date/Time control variables (must be before planet creation)
        let currentDate = new Date();  // Simulation date
        let simulationStartTime = Date.now();  // Real time when simulation started
        let useSpecificDate = false;

        // Create planets
        const planetMeshes = {};
        const orbitLines = {};

        Object.keys(PLANETS).forEach(id => {
            const planet = PLANETS[id];

            // Elliptical orbit line with real 3D orientation
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = createEllipticalOrbit(planet);
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: planet.color,  // Match planet color
                transparent: true,
                opacity: 0.4
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            orbitLines[id] = orbitLine;

            // Planet
            const geometry = new THREE.SphereGeometry(planet.radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: planet.color,
                emissive: planet.color,
                emissiveIntensity: 0.3,
                metalness: 0,
                roughness: 0.7
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Initialize planet at its actual position for current date
            const initialMeanAnomaly = getMeanAnomalyAtDate(planet, currentDate);
            const initialAngle = initialMeanAnomaly * Math.PI / 180;
            mesh.userData = { id, angle: initialAngle };

            // Set initial position
            const initialPos = getOrbitalPosition(planet, initialAngle);
            mesh.position.set(initialPos.x, initialPos.y, initialPos.z);

            scene.add(mesh);
            planetMeshes[id] = mesh;

            // Special: Saturn rings
            if (id === 'saturn') {
                const ringGeometry = new THREE.RingGeometry(3, 5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xC9B887,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                mesh.add(ring);
            }
        });

        // Create 3D planet labels using sprites
        const planetLabels = {};
        Object.keys(PLANETS).forEach(id => {
            const planet = PLANETS[id];

            // Create canvas for text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // Draw text
            context.fillStyle = 'rgba(0, 0, 0, 0.6)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = planet.color;
            context.lineWidth = 2;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);

            context.font = 'Bold 32px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(planet.name.toUpperCase(), canvas.width / 2, canvas.height / 2);

            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(15, 4, 1);  // Adjust size

            scene.add(sprite);
            planetLabels[id] = sprite;
        });

        // Create moons
        const moonMeshes = {};
        Object.keys(MOONS).forEach(id => {
            const moon = MOONS[id];
            const parentPlanet = PLANETS[moon.parent];

            // Create moon sphere with accurate size but minimum for visibility
            // moon.radius is already relative to Earth (same as planet radii)
            const moonSize = Math.max(0.08, moon.radius);  // Minimum 0.08 units for visibility

            const geometry = new THREE.SphereGeometry(moonSize, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: moon.color,
                emissive: moon.color,
                emissiveIntensity: 0.3,
                metalness: 0.1,
                roughness: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Initialize moon at its position relative to parent planet
            const initialAngle = moon.meanAnomalyEpoch * Math.PI / 180;
            mesh.userData = { id, angle: initialAngle, parent: moon.parent };

            scene.add(mesh);
            moonMeshes[id] = mesh;
        });

        // Controls
        let isPaused = false;
        let timeSpeed = 1;
        let selectedPlanet = null;

        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let cameraAngleX = 0;
        let cameraAngleY = Math.atan2(50, 80);  // Updated for better view of orbital planes
        let cameraDistance = 95;

        // Mouse controls
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMouse = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouse.x;
                const deltaY = e.clientY - previousMouse.y;
                cameraAngleX -= deltaX * 0.005;
                cameraAngleY += deltaY * 0.005;
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));
                previousMouse = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

        // Touch controls
        let touchStartDistance = 0;
        let touchStartCameraDistance = 70;

        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchStartDistance = getTouchDistance(e.touches[0], e.touches[1]);
                touchStartCameraDistance = cameraDistance;
            } else if (e.touches.length === 1) {
                isDragging = true;
                previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                const scale = touchStartDistance / currentDistance;
                cameraDistance = touchStartCameraDistance * scale;
                cameraDistance = Math.max(15, Math.min(800, cameraDistance));  // Allow viewing entire solar system
            } else if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - previousMouse.x;
                const deltaY = e.touches[0].clientY - previousMouse.y;
                cameraAngleX -= deltaX * 0.01;
                cameraAngleY += deltaY * 0.01;
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));
                previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', () => isDragging = false);

        // Scroll zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1.1 : 0.9;
            cameraDistance *= delta;
            cameraDistance = Math.max(15, Math.min(800, cameraDistance));  // Allow viewing entire solar system
        }, { passive: false });

        // UI
        const planetListEl = document.getElementById('planetList');

        // Add Sun to the list first
        const sunItem = document.createElement('div');
        sunItem.className = 'planet-item';
        sunItem.innerHTML = `
            <div class="planet-color" style="background-color: #FDB813;"></div>
            <div class="planet-name">Sun</div>
        `;
        sunItem.addEventListener('click', () => selectPlanet('sun'));
        planetListEl.appendChild(sunItem);

        // Add planets
        Object.keys(PLANETS).forEach(id => {
            const planet = PLANETS[id];
            const item = document.createElement('div');
            item.className = 'planet-item';
            item.innerHTML = `
                <div class="planet-color" style="background-color: ${planet.color}"></div>
                <div class="planet-name">${planet.name}</div>
            `;
            item.addEventListener('click', () => selectPlanet(id));
            planetListEl.appendChild(item);
        });

        function selectPlanet(id) {
            selectedPlanet = id === 'sun' ? null : id;  // Sun = no planet selection for camera

            // Update selected state in UI
            document.querySelectorAll('.planet-item').forEach(el => {
                const name = el.querySelector('.planet-name').textContent.toLowerCase();
                el.classList.toggle('selected', name === (id === 'sun' ? 'sun' : PLANETS[id]?.name.toLowerCase()));
            });

            // Show info panel
            const infoPanel = document.getElementById('infoPanel');
            infoPanel.style.display = 'block';

            if (id === 'sun') {
                document.getElementById('planetTitle').textContent = 'Sun';
                document.getElementById('planetDesc').textContent = 'The star at the center of our Solar System, containing 99.86% of the system\'s mass.';
                document.getElementById('planetStats').innerHTML = `
                    <div class="stat">
                        <span class="stat-label">Type</span>
                        <span class="stat-value">G-type Main Sequence Star</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Radius</span>
                        <span class="stat-value">695,700 km</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Surface Temperature</span>
                        <span class="stat-value">5,778 K</span>
                    </div>
                `;
            } else {
                const planet = PLANETS[id];
                document.getElementById('planetTitle').textContent = planet.name;
                document.getElementById('planetDesc').textContent = planet.desc;
                document.getElementById('planetStats').innerHTML = `
                    <div class="stat">
                        <span class="stat-label">Radius</span>
                        <span class="stat-value">${planet.radius.toFixed(2)} √ó Earth</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Orbital Period</span>
                        <span class="stat-value">${planet.orbit} days</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Day Length</span>
                        <span class="stat-value">${planet.rotation.toFixed(2)} Earth days</span>
                    </div>
                `;
            }
        }

        // Hamburger menu toggle
        let planetPanelOpen = false;
        document.getElementById('hamburgerBtn').addEventListener('click', () => {
            planetPanelOpen = !planetPanelOpen;
            const panel = document.getElementById('planetListPanel');
            panel.style.transform = planetPanelOpen ? 'translateX(0)' : 'translateX(calc(-100% - 20px))';
        });

        document.getElementById('closePlanets').addEventListener('click', () => {
            planetPanelOpen = false;
            document.getElementById('planetListPanel').style.transform = 'translateX(calc(-100% - 20px))';
        });

        // Time slider functionality
        let isSliderDragging = false;
        let sliderDragPosition = 0;  // -1 (left) to 1 (right), 0 is center
        let timeSliderActive = false;

        const sliderHandle = document.getElementById('timeSliderHandle');
        const sliderTrack = document.getElementById('timeSliderTrack');
        const currentDateDisplay = document.getElementById('currentDateDisplay');
        const timeSpeedDisplay = document.getElementById('timeSpeedDisplay');

        // Convert slider position to time speed with gradual progression
        function calculateTimeSpeed(sliderPosition) {
            const absPos = Math.abs(sliderPosition);

            if (absPos < 0.05) return 0;  // Dead zone

            let speed;
            // Gradual progression: mins ‚Üí hours ‚Üí days ‚Üí weeks ‚Üí months ‚Üí years
            if (absPos < 0.15) {
                // Minutes per second: 1-60 mins/s = 0.0007-0.042 days/s
                const t = (absPos - 0.05) / 0.1;  // 0 to 1
                speed = 0.0007 + t * 0.0413;  // 1 min/s to 60 min/s
            } else if (absPos < 0.3) {
                // Hours per second: 1-24 hours/s = 0.042-1 days/s
                const t = (absPos - 0.15) / 0.15;  // 0 to 1
                speed = 0.042 + t * 0.958;
            } else if (absPos < 0.5) {
                // Days per second: 1-7 days/s
                const t = (absPos - 0.3) / 0.2;
                speed = 1 + t * 6;
            } else if (absPos < 0.7) {
                // Weeks per second: 1-4 weeks/s = 7-28 days/s
                const t = (absPos - 0.5) / 0.2;
                speed = 7 + t * 21;
            } else if (absPos < 0.85) {
                // Months per second: 1-12 months/s = 30-365 days/s
                const t = (absPos - 0.7) / 0.15;
                speed = 30 + t * 335;
            } else {
                // Years per second: 1-10 years/s = 365-3650 days/s
                const t = (absPos - 0.85) / 0.15;
                speed = 365 + t * 3285;
            }

            return Math.sign(sliderPosition) * speed;
        }

        function updateTimeSpeedDisplay() {
            if (isPaused) {
                timeSpeedDisplay.textContent = 'Paused';
                timeSpeedDisplay.style.color = '#888';
            } else {
                const absSpeed = Math.abs(timeSpeed);
                const direction = timeSpeed > 0 ? '‚Üí' : '‚Üê';
                let speedText = '';

                // Display speed in appropriate units
                if (absSpeed < 0.042) {
                    // Minutes per second
                    const mins = Math.round(absSpeed * 1440);  // 1440 mins in a day
                    speedText = `${mins} min/s`;
                } else if (absSpeed < 1) {
                    // Hours per second
                    const hours = Math.round(absSpeed * 24);
                    speedText = `${hours} hr/s`;
                } else if (absSpeed < 7) {
                    // Days per second
                    speedText = `${absSpeed.toFixed(1)} days/s`;
                } else if (absSpeed < 30) {
                    // Weeks per second
                    const weeks = Math.round(absSpeed / 7);
                    speedText = `${weeks} week/s`;
                } else if (absSpeed < 365) {
                    // Months per second
                    const months = Math.round(absSpeed / 30);
                    speedText = `${months} mo/s`;
                } else {
                    // Years per second
                    const years = (absSpeed / 365).toFixed(1);
                    speedText = `${years} yr/s`;
                }

                timeSpeedDisplay.textContent = `${direction} ${speedText}`;
                timeSpeedDisplay.style.color = timeSpeed > 0 ? '#4CAF50' : '#FF9800';
            }
        }

        function formatDateDisplay(date) {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()} ${hours}:${minutes}`;
        }

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Initialize hidden date picker with current date
        const hiddenDatePicker = document.getElementById('hiddenDatePicker');
        hiddenDatePicker.value = formatDateForInput(currentDate);

        // Handle date selection
        hiddenDatePicker.addEventListener('change', (e) => {
            const selectedDate = new Date(e.target.value);
            if (!isNaN(selectedDate.getTime())) {
                currentDate = selectedDate;
                simulationStartTime = Date.now();
                isPaused = true;
                timeSpeed = 0;
                updateTimeSpeedDisplay();
                currentDateDisplay.textContent = formatDateDisplay(currentDate) + ' üìÖ';

                // Update all planet positions immediately
                Object.keys(planetMeshes).forEach(id => {
                    const planet = PLANETS[id];
                    const mesh = planetMeshes[id];
                    const meanAnomaly = getMeanAnomalyAtDate(planet, currentDate);
                    mesh.userData.angle = meanAnomaly * Math.PI / 180;
                    const pos = getOrbitalPosition(planet, mesh.userData.angle);
                    mesh.position.set(pos.x, pos.y, pos.z);
                });
            }
        });

        sliderHandle.addEventListener('mousedown', startSliderDrag);
        sliderHandle.addEventListener('touchstart', startSliderDrag, { passive: false });

        function startSliderDrag(e) {
            e.preventDefault();
            isSliderDragging = true;
            timeSliderActive = true;
            sliderHandle.style.cursor = 'grabbing';
            sliderHandle.style.transform = 'translate(-50%, -50%) scale(1.2)';
        }

        window.addEventListener('mousemove', (e) => {
            if (!isSliderDragging) return;
            const rect = sliderTrack.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const offsetX = e.clientX - centerX;
            const maxOffset = rect.width / 2;
            sliderDragPosition = Math.max(-1, Math.min(1, offsetX / maxOffset));

            // Update handle position
            const handlePosition = 50 + (sliderDragPosition * 40);  // 50% ¬± 40%
            sliderHandle.style.left = `${handlePosition}%`;

            // Calculate time speed with gradual progression
            timeSpeed = calculateTimeSpeed(sliderDragPosition);
            isPaused = (timeSpeed === 0);

            updateTimeSpeedDisplay();
        });

        window.addEventListener('touchmove', (e) => {
            if (!isSliderDragging || e.touches.length === 0) return;
            const rect = sliderTrack.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const offsetX = e.touches[0].clientX - centerX;
            const maxOffset = rect.width / 2;
            sliderDragPosition = Math.max(-1, Math.min(1, offsetX / maxOffset));

            // Update handle position
            const handlePosition = 50 + (sliderDragPosition * 40);
            sliderHandle.style.left = `${handlePosition}%`;

            // Calculate time speed with gradual progression
            timeSpeed = calculateTimeSpeed(sliderDragPosition);
            isPaused = (timeSpeed === 0);

            updateTimeSpeedDisplay();
        }, { passive: false });

        window.addEventListener('mouseup', stopSliderDrag);
        window.addEventListener('touchend', stopSliderDrag);

        function stopSliderDrag() {
            if (!isSliderDragging) return;
            isSliderDragging = false;
            timeSliderActive = false;
            sliderHandle.style.cursor = 'grab';
            sliderHandle.style.transform = 'translate(-50%, -50%) scale(1)';

            // Return to center
            sliderHandle.style.left = '50%';
            sliderDragPosition = 0;

            // Keep the time speed that was set
            updateTimeSpeedDisplay();
        }

        document.getElementById('pauseBtn2').addEventListener('click', () => {
            isPaused = !isPaused;
            if (isPaused) {
                timeSpeed = 0;
            } else if (timeSpeed === 0) {
                timeSpeed = 1;
            }
            updateTimeSpeedDisplay();
            document.getElementById('pauseBtn2').textContent = isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        });

        document.getElementById('resetDateBtn2').addEventListener('click', () => {
            currentDate = new Date();
            simulationStartTime = Date.now();
            isPaused = false;
            timeSpeed = 0;
            updateTimeSpeedDisplay();
            currentDateDisplay.textContent = formatDateDisplay(currentDate) + ' üìÖ';
            hiddenDatePicker.value = formatDateForInput(currentDate);

            // Reset all planet positions
            Object.keys(planetMeshes).forEach(id => {
                const planet = PLANETS[id];
                const mesh = planetMeshes[id];
                const meanAnomaly = getMeanAnomalyAtDate(planet, currentDate);
                mesh.userData.angle = meanAnomaly * Math.PI / 180;
                const pos = getOrbitalPosition(planet, mesh.userData.angle);
                mesh.position.set(pos.x, pos.y, pos.z);
            });
        });

        document.getElementById('minimizeInfo').addEventListener('click', (e) => {
            const panel = document.getElementById('infoPanel');
            const btn = e.target;
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Update planets
            if (!isPaused) {
                // Advance simulation time
                const frameTimeAdvance = 0.01 * timeSpeed * 86400000;  // Convert days to milliseconds
                currentDate = new Date(currentDate.getTime() + frameTimeAdvance);

                Object.keys(planetMeshes).forEach(id => {
                    const planet = PLANETS[id];
                    const mesh = planetMeshes[id];

                    // Calculate mean anomaly from current simulation date
                    const meanAnomaly = getMeanAnomalyAtDate(planet, currentDate);
                    mesh.userData.angle = meanAnomaly * Math.PI / 180;

                    // Calculate position on elliptical orbit
                    const pos = getOrbitalPosition(planet, mesh.userData.angle);
                    mesh.position.set(pos.x, pos.y, pos.z);

                    // Planet rotation
                    mesh.rotation.y += 0.01 / planet.rotation;
                });

                sun.rotation.y += 0.001;
                glow.rotation.y += 0.001;

                // Update moons (orbiting their parent planets)
                Object.keys(moonMeshes).forEach(id => {
                    const moon = MOONS[id];
                    const mesh = moonMeshes[id];
                    const parentMesh = planetMeshes[moon.parent];

                    // Advance moon's orbital angle
                    const meanMotion = (Math.PI * 2 / Math.abs(moon.orbit));  // radians per day
                    const direction = moon.orbit > 0 ? 1 : -1;  // Handle retrograde orbits (Triton)
                    mesh.userData.angle += meanMotion * 0.01 * timeSpeed * direction;

                    // Calculate moon position using Keplerian elements relative to parent
                    const pos = getOrbitalPosition({
                        semiMajorAxis: moon.semiMajorAxis,
                        eccentricity: moon.eccentricity,
                        inclination: moon.inclination,
                        longitudeAscending: moon.longitudeAscending,
                        argumentPeriapsis: moon.argumentPeriapsis
                    }, mesh.userData.angle);

                    // Position relative to parent planet
                    mesh.position.set(
                        parentMesh.position.x + pos.x,
                        parentMesh.position.y + pos.y,
                        parentMesh.position.z + pos.z
                    );
                });

                // Update date display
                if (Math.random() < 0.1) {  // Update occasionally
                    currentDateDisplay.textContent = formatDateDisplay(currentDate) + ' üìÖ';
                }
            }

            // Update camera
            if (selectedPlanet && planetMeshes[selectedPlanet]) {
                const targetPos = planetMeshes[selectedPlanet].position;
                const currentLookAt = new THREE.Vector3();
                camera.getWorldDirection(currentLookAt);
                currentLookAt.multiplyScalar(cameraDistance).add(camera.position);
                currentLookAt.lerp(targetPos, 0.05);

                const desiredDistance = PLANETS[selectedPlanet].radius * 8 + 10;
                cameraDistance += (desiredDistance - cameraDistance) * 0.05;
            }

            camera.position.x = cameraDistance * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
            camera.position.y = cameraDistance * Math.sin(cameraAngleY);
            camera.position.z = cameraDistance * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);

            if (selectedPlanet && planetMeshes[selectedPlanet]) {
                camera.lookAt(planetMeshes[selectedPlanet].position);
            } else {
                camera.lookAt(0, 0, 0);
            }

            // Keep stars centered on camera (infinitely distant - no parallax)
            stars.position.copy(camera.position);

            // Update planet labels to follow planets
            Object.keys(planetLabels).forEach(id => {
                const mesh = planetMeshes[id];
                const label = planetLabels[id];
                const planet = PLANETS[id];

                // Position label next to planet (offset based on planet size)
                const labelOffset = planet.radius * 2 + 3;
                label.position.set(
                    mesh.position.x,
                    mesh.position.y + labelOffset,
                    mesh.position.z
                );

                // Scale labels based on distance from camera for readability
                // Use inverse square root for better scaling at all distances
                const distance = camera.position.distanceTo(mesh.position);
                const baseScale = Math.sqrt(distance) * 0.25;  // Much smaller base scale
                const scale = Math.max(0.2, Math.min(1.0, baseScale));
                label.scale.set(8 * scale, 2.1 * scale, 1);
            });

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Hide loading screen after first render
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.opacity = '0';
                loading.style.transition = 'opacity 0.5s';
                setTimeout(() => loading.remove(), 500);
            }
        }, 500);
    </script>
</body>
</html>
