<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Earth & Moon System - 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd60a;
            min-width: 200px;
            max-width: 250px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .controls.minimized {
            min-width: auto;
            max-width: none;
            padding: 10px;
        }

        .controls.minimized .control-content {
            display: none;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .controls.minimized .controls-header {
            margin-bottom: 0;
        }

        .controls h2 {
            color: #ffd60a;
            font-size: 16px;
            margin: 0;
        }

        .toggle-btn {
            background: none;
            border: none;
            color: #ffd60a;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            margin: 0;
            width: auto;
            min-width: 30px;
        }

        .toggle-btn:hover {
            transform: scale(1.1);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ffc300;
            font-size: 13px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #fff;
            font-weight: bold;
        }

        button {
            background: #ffd60a;
            color: #000;
            border: none;
            padding: 10px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            width: 100%;
            margin-top: 8px;
            transition: all 0.3s;
        }

        button:hover {
            background: #ffc300;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        .find-moon-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffd60a;
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 214, 10, 0.4);
            transition: all 0.3s;
            z-index: 100;
        }

        .find-moon-btn:hover {
            background: #ffc300;
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 214, 10, 0.6);
        }

        .find-moon-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .info-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #ffd60a;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
        }

        .info-overlay.visible {
            opacity: 1;
        }

        .info-overlay h3 {
            color: #ffd60a;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .info-overlay p {
            color: #fff;
            font-size: 14px;
        }

        .hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 13px;
            color: #ffd60a;
            opacity: 0.8;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="controls" id="controls">
        <div class="controls-header">
            <h2>üåç Controls</h2>
            <button class="toggle-btn" id="toggleControls">‚àí</button>
        </div>
        <div class="control-content">
            <div class="control-group">
                <label>Speed: <span class="value-display" id="speedValue">1.0x</span></label>
                <input type="range" id="speed" min="0" max="5" step="0.1" value="1">
            </div>

            <button id="resetView">üîÑ Reset View</button>
            <button id="pausePlay">‚è∏Ô∏è Pause</button>
        </div>
    </div>

    <button class="find-moon-btn" id="findMoon">üåô Find the Moon!</button>

    <div class="hint">Drag to rotate ‚Ä¢ Pinch/Scroll to zoom</div>

    <div class="info-overlay" id="infoOverlay">
        <h3>üåô Moon Found!</h3>
        <p>Drag to explore from different angles</p>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Space background
        scene.background = new THREE.Color(0x000814);

        // Add stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 4000;
            const y = (Math.random() - 0.5) * 4000;
            const z = (Math.random() - 0.5) * 4000;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(-1000, 500, -500);
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // Accurate scale: Earth radius = 60 units, Moon radius = 16 units (27% of Earth)
        // Distance = 600 units (10x compression from real 60x radius)

        // Create Earth
        const earthGeometry = new THREE.SphereGeometry(60, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0x1e90ff,
            emissive: 0x001122,
            shininess: 10,
            specular: 0x333333
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // Add Earth continents (simple approximation with spheres)
        const continentMaterial = new THREE.MeshPhongMaterial({
            color: 0x2e7d32,
            emissive: 0x001100
        });

        // Continent group
        const continents = new THREE.Group();

        // North America-ish
        const continent1 = new THREE.Mesh(
            new THREE.SphereGeometry(20, 32, 32),
            continentMaterial
        );
        continent1.position.set(-20, 20, 50);
        continents.add(continent1);

        // Africa-ish
        const continent2 = new THREE.Mesh(
            new THREE.SphereGeometry(18, 32, 32),
            continentMaterial
        );
        continent2.position.set(25, -10, 52);
        continents.add(continent2);

        // Asia-ish
        const continent3 = new THREE.Mesh(
            new THREE.SphereGeometry(22, 32, 32),
            continentMaterial
        );
        continent3.position.set(15, 30, 48);
        continents.add(continent3);

        earth.add(continents);

        // Add clouds
        const cloudsGeometry = new THREE.SphereGeometry(61, 64, 64);
        const cloudsMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            shininess: 0
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earth.add(clouds);

        // Create Moon
        const moonGeometry = new THREE.SphereGeometry(16, 32, 32);
        const moonMaterial = new THREE.MeshPhongMaterial({
            color: 0xc0c0c0,
            emissive: 0x111111,
            shininess: 5
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(600, 0, 0);
        scene.add(moon);

        // Add moon craters (simple bumps)
        const craterMaterial = new THREE.MeshPhongMaterial({
            color: 0x808080,
            emissive: 0x050505
        });

        const crater1 = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 16), craterMaterial);
        crater1.position.set(0, 5, 14);
        moon.add(crater1);

        const crater2 = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), craterMaterial);
        crater2.position.set(8, -3, 12);
        moon.add(crater2);

        const crater3 = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16), craterMaterial);
        crater3.position.set(-6, 7, 13);
        moon.add(crater3);

        // Moon orbit visualization (optional dashed line)
        const orbitCurve = new THREE.EllipseCurve(0, 0, 600, 600, 0, 2 * Math.PI, false, 0);
        const orbitPoints = orbitCurve.getPoints(100);
        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(
            orbitPoints.map(p => new THREE.Vector3(p.x, 0, p.y))
        );
        const orbitMaterial = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 10,
            gapSize: 10,
            transparent: true,
            opacity: 0.3
        });
        const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
        orbit.computeLineDistances();
        scene.add(orbit);

        // Camera setup
        camera.position.set(0, 200, 400);
        camera.lookAt(0, 0, 0);

        // Animation variables
        let animationSpeed = 1;
        let isPaused = false;
        let moonAngle = 0;

        // Camera controls variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngleX = 0;
        let cameraAngleY = Math.atan2(200, 400);
        let cameraDistance = 500;
        let targetCameraDistance = 500;

        // Touch controls
        let touchStartDistance = 0;
        let touchStartCameraDistance = 500;

        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Mouse controls
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngleX -= deltaX * 0.005;
                cameraAngleY += deltaY * 0.005;

                // Limit vertical rotation
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Mouse wheel zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1.1 : 0.9;
            targetCameraDistance *= delta;
            targetCameraDistance = Math.max(150, Math.min(2000, targetCameraDistance));
        }, { passive: false });

        // Touch controls
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchStartDistance = getTouchDistance(e.touches[0], e.touches[1]);
                touchStartCameraDistance = cameraDistance;
            } else if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 2) {
                const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                const scale = touchStartDistance / currentDistance;
                targetCameraDistance = touchStartCameraDistance * scale;
                targetCameraDistance = Math.max(150, Math.min(2000, targetCameraDistance));
            } else if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAngleX -= deltaX * 0.01;
                cameraAngleY += deltaY * 0.01;
                cameraAngleY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));

                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });

        // UI Controls
        document.getElementById('toggleControls').addEventListener('click', () => {
            const controls = document.getElementById('controls');
            const btn = document.getElementById('toggleControls');
            controls.classList.toggle('minimized');
            btn.textContent = controls.classList.contains('minimized') ? '+' : '‚àí';
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });

        document.getElementById('findMoon').addEventListener('click', () => {
            // Point camera at moon
            const moonWorldPos = new THREE.Vector3();
            moon.getWorldPosition(moonWorldPos);

            // Calculate angles to look at moon
            const distance = 200; // Closer view
            const direction = moonWorldPos.clone().normalize();

            cameraAngleX = Math.atan2(direction.x, direction.z);
            cameraAngleY = Math.asin(direction.y);
            targetCameraDistance = 200;

            // Show info overlay
            const overlay = document.getElementById('infoOverlay');
            overlay.classList.add('visible');
            setTimeout(() => {
                overlay.classList.remove('visible');
            }, 3000);
        });

        document.getElementById('resetView').addEventListener('click', () => {
            cameraAngleX = 0;
            cameraAngleY = Math.atan2(200, 400);
            targetCameraDistance = 500;
        });

        document.getElementById('pausePlay').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                // Rotate Earth
                earth.rotation.y += 0.001 * animationSpeed;
                clouds.rotation.y += 0.0012 * animationSpeed;

                // Orbit Moon
                moonAngle += 0.002 * animationSpeed;
                moon.position.x = Math.cos(moonAngle) * 600;
                moon.position.z = Math.sin(moonAngle) * 600;

                // Rotate Moon (tidally locked - same face towards Earth)
                moon.rotation.y = moonAngle + Math.PI;
            }

            // Smooth camera distance
            cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;

            // Update camera position based on angles
            camera.position.x = cameraDistance * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
            camera.position.y = cameraDistance * Math.sin(cameraAngleY);
            camera.position.z = cameraDistance * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
